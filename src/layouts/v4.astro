---
import SpeedInsights from '@vercel/speed-insights/astro';

interface Props {
	title: string;
	description?: string;
}
const { title, description } = Astro.props;
---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="description" content={description} />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<link rel="icon" type="image/png" href="/favicon.png" sizes="512x512" />
		<meta name="generator" content={Astro.generator} />
		<title>{title}</title>
	</head>
	<body class="bg-slate-950/95 text-white min-h-screen relative overflow-hidden">
		<!-- Particle Canvas Background -->
		<canvas id="particle-canvas" class="fixed top-0 left-0 w-full h-full -z-10"></canvas>

		<SpeedInsights />
		
		<script is:inline>
			// Particle System
			class ParticleSystem {
				constructor() {
					this.canvas = document.getElementById('particle-canvas');
					this.ctx = this.canvas.getContext('2d');
					this.particles = [];
					this.mouseX = 0;
					this.mouseY = 0;
					this.time = 0;
					
					this.resize();
					this.createParticles();
					this.bindEvents();
					this.animate();
				}
				
				resize() {
					this.canvas.width = window.innerWidth;
					this.canvas.height = window.innerHeight;
				}
				
				createParticles() {
					const particleCount = Math.min(4, Math.floor((this.canvas.width * this.canvas.height) / 100000));
					
					for (let i = 0; i < particleCount; i++) {
						this.particles.push(this.createShootingStar());
					}
				}
				
				createShootingStar() {
					// Create curved flight paths like airplanes
					const startX = -50 + Math.random() * (this.canvas.width + 100);
					const startY = -50 + Math.random() * (this.canvas.height + 100);
					
					// Create a destination point for curved path
					const destX = -50 + Math.random() * (this.canvas.width + 100);
					const destY = -50 + Math.random() * (this.canvas.height + 100);
					
					// Control point for curve (creates arc)
					const controlX = (startX + destX) / 2 + (Math.random() - 0.5) * 200;
					const controlY = (startY + destY) / 2 + (Math.random() - 0.5) * 200;
					
					return {
						x: startX,
						y: startY,
						startX: startX,
						startY: startY,
						controlX: controlX,
						controlY: controlY,
						destX: destX,
						destY: destY,
						progress: 0,
						speed: 0.0008 + Math.random() * 0.0015, // Much slower max speed
						size: Math.random() * 0.8 + 0.6, // Smaller, more realistic
						opacity: 0.7 + Math.random() * 0.3,
						trail: [],
						maxTrailLength: 12 + Math.random() * 8, // Longer trails
						life: 1.0,
						fadeRate: 0.0005 + Math.random() * 0.0008, // Much slower fade
						// Blinking properties
						blinkPhase: Math.random() * Math.PI * 2,
						blinkSpeed: 0.003 + Math.random() * 0.002,
						isBlinking: true
					};
				}
				
				bindEvents() {
					window.addEventListener('resize', () => {
						this.resize();
						this.particles = [];
						this.createParticles();
					});
					
					this.canvas.addEventListener('mousemove', (e) => {
						this.mouseX = e.clientX;
						this.mouseY = e.clientY;
					});
				}
				
				// Quadratic Bezier curve interpolation for curved paths
				getBezierPoint(t, start, control, end) {
					const invT = 1 - t;
					return {
						x: invT * invT * start.x + 2 * invT * t * control.x + t * t * end.x,
						y: invT * invT * start.y + 2 * invT * t * control.y + t * t * end.y
					};
				}
				
				updateParticle(particle) {
					// Update progress along curved path
					particle.progress += particle.speed;
					
					// Calculate position on Bezier curve
					const position = this.getBezierPoint(
						particle.progress,
						{ x: particle.startX, y: particle.startY },
						{ x: particle.controlX, y: particle.controlY },
						{ x: particle.destX, y: particle.destY }
					);
					
					// Add current position to trail
					particle.trail.push({ x: particle.x, y: particle.y, opacity: particle.life });
					
					// Update position
					particle.x = position.x;
					particle.y = position.y;
					
					// Limit trail length
					if (particle.trail.length > particle.maxTrailLength) {
						particle.trail.shift();
					}
					
					// Update blinking (airplane navigation lights)
					particle.currentBlink = 0.3 + 0.7 * Math.abs(Math.sin(this.time * particle.blinkSpeed + particle.blinkPhase));
					
					// Fade out over time (much slower)
					particle.life -= particle.fadeRate;
					
					// Reset if progress complete or faded out
					if (particle.progress >= 1 || particle.life <= 0) {
						// Create new airplane path
						const newStar = this.createShootingStar();
						Object.assign(particle, newStar);
					}
				}
				
				drawParticles() {
					this.particles.forEach(particle => {
						// Draw trail (more persistent and subtle)
						if (particle.trail.length > 1) {
							for (let i = 1; i < particle.trail.length; i++) {
								const current = particle.trail[i];
								const previous = particle.trail[i - 1];
								const trailOpacity = (i / particle.trail.length) * particle.life * 0.08;
								
								this.ctx.strokeStyle = `rgba(148, 163, 184, ${trailOpacity})`;
								this.ctx.lineWidth = 0.5;
								this.ctx.beginPath();
								this.ctx.moveTo(previous.x, previous.y);
								this.ctx.lineTo(current.x, current.y);
								this.ctx.stroke();
							}
						}
						
						// Draw airplane light with blinking
						const finalOpacity = particle.opacity * particle.life * particle.currentBlink;
						
						this.ctx.beginPath();
						this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
						this.ctx.fillStyle = `rgba(148, 163, 184, ${finalOpacity})`;
						this.ctx.fill();
						
						// Add a very subtle glow (no dramatic effects)
						this.ctx.beginPath();
						this.ctx.arc(particle.x, particle.y, particle.size * 1.5, 0, Math.PI * 2);
						this.ctx.fillStyle = `rgba(148, 163, 184, ${finalOpacity * 0.2})`;
						this.ctx.fill();
					});
				}
				
				animate() {
					this.time += 16;
					
					// Clear completely (no trail effect)
					this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
					
					// Update and draw particles only (no connections)
					this.particles.forEach(particle => this.updateParticle(particle));
					this.drawParticles();
					
					requestAnimationFrame(() => this.animate());
				}
			}
			
			// Initialize when DOM is loaded
			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', () => new ParticleSystem());
			} else {
				new ParticleSystem();
			}
		</script>
	</body>
</html>

<style is:global>
	* {
		margin: 0;
		padding: 0;
		box-sizing: border-box;
	}
	
	html, body {
		font-family: system-ui, sans-serif;
		overflow-x: hidden;
	}
	
	body {
		background: linear-gradient(180deg, #020617 0%, #0f172a 50%, #1e293b 100%);
		min-height: 100vh;
	}

	/* Custom scrollbar for webkit browsers */
	::-webkit-scrollbar {
		width: 8px;
	}
	
	::-webkit-scrollbar-track {
		background: #1e293b;
	}
	
	::-webkit-scrollbar-thumb {
		background: #475569;
		border-radius: 4px;
	}
	
	::-webkit-scrollbar-thumb:hover {
		background: #64748b;
	}

	/* Responsive adjustments */
	@media (max-width: 1024px) {
		main {
			flex-direction: column;
			align-items: center;
			text-align: center;
		}
		
		.flex-1.max-w-lg.ml-16 {
			margin-left: 0;
			margin-top: 3rem;
			max-width: 100%;
		}
	}
	
	@media (max-width: 768px) {
		nav {
			padding-top: 1.5rem;
			padding-bottom: 2rem;
		}
		
		nav > div {
			flex-wrap: wrap;
			gap: 1rem;
			padding: 0.75rem 1.5rem;
		}
		
		h1 {
			font-size: 4rem !important;
		}
		
		.bg-slate-300 span {
			font-size: 3rem !important;
		}
	}
</style>
