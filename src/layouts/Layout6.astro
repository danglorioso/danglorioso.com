---
import '../globals.css';
import SpeedInsights from '@vercel/speed-insights/astro';
import Header from '../components/Header_v3.astro';
import Footer from '../components/Footer';

interface Props {
  title: string;
  description?: string;
}
const { title, description } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content={description} />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="icon" type="image/png" href="/favicon.png" sizes="512x512" />
    <meta name="generator" content={Astro.generator} />
    <title>{title} | Dan Glorioso</title>
  </head>
  
  <body class="min-h-screen">
    <canvas id="navigation-canvas" class="fixed top-0 left-0 w-full h-full pointer-events-none" style="background: var(--bg-primary, #0f172a);"></canvas>

    <!-- Vercel Speed Insights -->
    <SpeedInsights />

    <div class="flex flex-col gap-4">
      <!-- Header -->
      <Header />

      <!-- Header spacer to prevent content from being hidden behind fixed header -->
      <div class="h-20 sm:h-22"></div>

      <!-- Mobile Menu (slides from behind header) -->
      <div 
        id="mobile-menu" 
        class="md:hidden fixed left-0 right-0 z-40 transform -translate-y-full transition-all duration-300 ease-in-out pointer-events-none"
        aria-hidden="true"
      >
        <!-- Full Screen Backdrop -->
        <div class="fixed inset-0 bg-black/50 backdrop-blur-sm z-30" id="mobile-menu-backdrop"></div>
        
        <!-- Menu Panel that slides from behind header -->
        <div class="relative z-40 bg-slate-900 border-b border-slate-700/50 shadow-2xl pt-20">
          <!-- Navigation Links -->
          <nav class="px-6 py-6">
            <ul class="space-y-2" id="mobile-nav-links">
              <!-- Navigation items will be populated by JavaScript -->
            </ul>
          </nav>
        </div>
      </div>

      <!-- Page Content -->
      <main class="flex flex-col max-w-5xl px-8 md:px-16 py-8 mx-auto w-full relative z-0">
        <slot />
      </main>

      <!-- Footer -->
      <Footer />
    </div>

    <!-- Back to Top Button -->
    <button 
      id="back-to-top"
      class="fixed bottom-6 right-6 p-3 z-[100] bg-slate-850/90 hover:bg-slate-800/90 backdrop-blur-sm border border-slate-700/50 rounded-full shadow-lg transition-all duration-300 opacity-0 translate-y-2 pointer-events-none group"
      aria-label="Back to top"
    >
      <svg 
        class="w-5 h-5 mx-auto text-gray-300 group-hover:text-white transition-colors duration-200" 
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18"></path>
      </svg>
    </button>

    <script is:inline>
      // Navigation Waypoints & Flight Paths - Aviation Chart Style
      class NavigationChart {
        constructor() {
          this.canvas = document.getElementById('navigation-canvas');
          this.ctx = this.canvas.getContext('2d');
          this.bgColor = this.getBackgroundColor();
          this.waypoints = [];
          this.flightPaths = [];
          this.time = 0;

          this.resize();
          this.createWaypoints();
          this.createFlightPaths();
          this.bindEvents();
          this.animate();
        }

        getBackgroundColor() {
          const bgColor = getComputedStyle(document.documentElement)
            .getPropertyValue('--bg-primary')
            .trim();
          return bgColor || '#0f172a';
        }

        getAccentColor() {
          const accentColor = getComputedStyle(document.documentElement)
            .getPropertyValue('--accent-primary')
            .trim() || 'rgb(59, 130, 246)';

          let r, g, b;
          if (accentColor.startsWith('oklch')) {
            r = 59; g = 130; b = 246;
          } else if (accentColor.startsWith('#')) {
            const hex = accentColor.slice(1);
            r = parseInt(hex.slice(0, 2), 16);
            g = parseInt(hex.slice(2, 4), 16);
            b = parseInt(hex.slice(4, 6), 16);
          } else if (accentColor.startsWith('rgb')) {
            const matches = accentColor.match(/\d+/g);
            r = parseInt(matches[0]);
            g = parseInt(matches[1]);
            b = parseInt(matches[2]);
          } else {
            r = 59; g = 130; b = 246;
          }

          return { r, g, b };
        }

        resize() {
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;
        }

        createWaypoints() {
          this.waypoints = [];
          const waypointCount = 12;
          const spacing = Math.min(this.canvas.width, this.canvas.height) / 4;

          for (let i = 0; i < waypointCount; i++) {
            const x = spacing + Math.random() * (this.canvas.width - spacing * 2);
            const y = spacing + Math.random() * (this.canvas.height - spacing * 2);
            
            this.waypoints.push({
              x,
              y,
              radius: 4 + Math.random() * 3,
              pulsePhase: Math.random() * Math.PI * 2,
              pulseSpeed: 0.003 + Math.random() * 0.004,
            });
          }
        }

        createFlightPaths() {
          this.flightPaths = [];
          const accent = this.getAccentColor();
          const pathCount = 5;

          for (let i = 0; i < pathCount; i++) {
            const startIdx = Math.floor(Math.random() * this.waypoints.length);
            const endIdx = Math.floor(Math.random() * this.waypoints.length);
            
            if (startIdx === endIdx) continue;

            const start = this.waypoints[startIdx];
            const end = this.waypoints[endIdx];

            // Create curved path using waypoints
            const midX = (start.x + end.x) / 2 + (Math.random() - 0.5) * 100;
            const midY = (start.y + end.y) / 2 + (Math.random() - 0.5) * 100;

            this.flightPaths.push({
              startX: start.x,
              startY: start.y,
              midX,
              midY,
              endX: end.x,
              endY: end.y,
              progress: Math.random(),
              speed: 0.0002 + Math.random() * 0.0003,
              opacity: 0.12 + Math.random() * 0.08,
              color: accent,
              width: 1,
            });
          }
        }

        bindEvents() {
          window.addEventListener('resize', () => {
            this.resize();
            this.createWaypoints();
            this.createFlightPaths();
          });
        }

        getPointOnCurve(path, t) {
          // Quadratic BÃ©zier curve
          const u = 1 - t;
          const tt = t * t;
          const uu = u * u;

          const x = uu * path.startX + 2 * u * t * path.midX + tt * path.endX;
          const y = uu * path.startY + 2 * u * t * path.midY + tt * path.endY;

          return { x, y };
        }

        drawGrid() {
          const accent = this.getAccentColor();
          const gridSize = 100;
          const opacity = 0.04;

          this.ctx.strokeStyle = `rgba(${accent.r}, ${accent.g}, ${accent.b}, ${opacity})`;
          this.ctx.lineWidth = 0.5;

          // Vertical lines
          for (let x = 0; x < this.canvas.width; x += gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.canvas.height);
            this.ctx.stroke();
          }

          // Horizontal lines
          for (let y = 0; y < this.canvas.height; y += gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
          }
        }

        drawWaypoints() {
          const accent = this.getAccentColor();

          this.waypoints.forEach(waypoint => {
            const pulse = Math.sin(this.time * waypoint.pulseSpeed + waypoint.pulsePhase) * 0.3 + 0.7;
            const currentRadius = waypoint.radius * pulse;
            const opacity = 0.3 + pulse * 0.2;

            // Outer ring (navigation beacon style)
            this.ctx.beginPath();
            this.ctx.arc(waypoint.x, waypoint.y, currentRadius * 2.5, 0, Math.PI * 2);
            this.ctx.strokeStyle = `rgba(${accent.r}, ${accent.g}, ${accent.b}, ${opacity * 0.3})`;
            this.ctx.lineWidth = 1;
            this.ctx.stroke();

            // Inner circle
            this.ctx.beginPath();
            this.ctx.arc(waypoint.x, waypoint.y, currentRadius, 0, Math.PI * 2);
            this.ctx.fillStyle = `rgba(${accent.r}, ${accent.g}, ${accent.b}, ${opacity})`;
            this.ctx.fill();

            // Center dot
            this.ctx.beginPath();
            this.ctx.arc(waypoint.x, waypoint.y, currentRadius * 0.4, 0, Math.PI * 2);
            this.ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.8})`;
            this.ctx.fill();
          });
        }

        drawFlightPaths() {
          this.flightPaths.forEach(path => {
            path.progress += path.speed * 16;
            if (path.progress > 1) path.progress = 0;

            const { r, g, b } = path.color;

            // Draw path line
            this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${path.opacity * 0.4})`;
            this.ctx.lineWidth = path.width;
            this.ctx.beginPath();
            this.ctx.moveTo(path.startX, path.startY);
            this.ctx.quadraticCurveTo(path.midX, path.midY, path.endX, path.endY);
            this.ctx.stroke();

            // Draw aircraft position
            const pos = this.getPointOnCurve(path, path.progress);
            const ahead = this.getPointOnCurve(path, Math.min(path.progress + 0.02, 1));
            const angle = Math.atan2(ahead.y - pos.y, ahead.x - pos.x);

            // Aircraft triangle
            this.ctx.save();
            this.ctx.translate(pos.x, pos.y);
            this.ctx.rotate(angle);

            const size = 6;
            this.ctx.beginPath();
            this.ctx.moveTo(size, 0);
            this.ctx.lineTo(-size * 0.6, -size * 0.4);
            this.ctx.lineTo(-size * 0.6, size * 0.4);
            this.ctx.closePath();
            this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${path.opacity * 1.2})`;
            this.ctx.fill();

            // Navigation light
            this.ctx.beginPath();
            this.ctx.arc(size * 0.3, 0, 2, 0, Math.PI * 2);
            this.ctx.fillStyle = `rgba(255, 255, 255, ${path.opacity * 1.5})`;
            this.ctx.fill();

            this.ctx.restore();
          });
        }

        animate() {
          this.time += 16;

          // Clear canvas
          this.ctx.fillStyle = this.bgColor;
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          // Draw elements
          this.drawGrid();
          this.drawWaypoints();
          this.drawFlightPaths();

          requestAnimationFrame(() => this.animate());
        }
      }

      // Back to Top Button Functionality
      function initBackToTop() {
        const backToTopBtn = document.getElementById('back-to-top');
        if (!backToTopBtn) return;

        function toggleButtonVisibility() {
          const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
          
          if (scrollTop > 300) {
            backToTopBtn.classList.remove('opacity-0', 'translate-y-2', 'pointer-events-none');
            backToTopBtn.classList.add('opacity-100', 'translate-y-0');
          } else {
            backToTopBtn.classList.add('opacity-0', 'translate-y-2', 'pointer-events-none');
            backToTopBtn.classList.remove('opacity-100', 'translate-y-0');
          }
        }

        function scrollToTop() {
          window.scrollTo({
            top: 0,
            behavior: 'smooth'
          });
        }

        window.addEventListener('scroll', toggleButtonVisibility);
        backToTopBtn.addEventListener('click', scrollToTop);
        toggleButtonVisibility();
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          new NavigationChart();
          initBackToTop();
        });
      } else {
        new NavigationChart();
        initBackToTop();
      }
    </script>
  </body>
</html>

<style is:global>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  html, body {
    font-family: -apple-system, BlinkMacSystemFont, Inter, system-ui, sans-serif;
    overflow-x: hidden;
  }
  
  body {
    background: var(--bg-primary);
    min-height: 100vh;
  }
  
  /* Text selection highlight color */
  ::selection {
    background-color: var(--accent-primary);
    color: var(--text-primary);
  }
  
  ::-moz-selection {
    background-color: var(--accent-primary);
    color: var(--text-primary);
  }
</style>

