---
import '../globals.css';
import SpeedInsights from '@vercel/speed-insights/astro';
import Header from '../components/Header_v3.astro';
import Footer from '../components/Footer.tsx';

interface Props {
  title: string;
  description?: string;
}
const { title, description } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content={description} />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="icon" type="image/png" href="/favicon.png" sizes="512x512" />
    <meta name="generator" content={Astro.generator} />
    <title>{title} | Dan Glorioso</title>
  </head>
  
  <body class="min-h-screen">
    <canvas id="constellation-canvas" class="fixed top-0 left-0 w-full h-full pointer-events-none" style="background: var(--bg-primary, #0f172a);"></canvas>

    <!-- Vercel Speed Insights -->
    <SpeedInsights />

    <div class="flex flex-col gap-4">
      <!-- Header -->
      <Header />

      <!-- Header spacer to prevent content from being hidden behind fixed header -->
      <div class="h-20 sm:h-22"></div>

      <!-- Mobile Menu (slides from behind header) -->
      <div 
        id="mobile-menu" 
        class="md:hidden fixed left-0 right-0 z-40 transform -translate-y-full transition-all duration-300 ease-in-out pointer-events-none"
        aria-hidden="true"
      >
        <!-- Full Screen Backdrop -->
        <div class="fixed inset-0 bg-black/50 backdrop-blur-sm z-30" id="mobile-menu-backdrop"></div>
        
        <!-- Menu Panel that slides from behind header -->
        <div class="relative z-40 bg-slate-900 border-b border-slate-700/50 shadow-2xl pt-20">
          <!-- Navigation Links -->
          <nav class="px-6 py-6">
            <ul class="space-y-2" id="mobile-nav-links">
              <!-- Navigation items will be populated by JavaScript -->
            </ul>
          </nav>
        </div>
      </div>

      <!-- Page Content -->
      <main class="flex flex-col max-w-5xl px-8 md:px-16 py-8 mx-auto w-full relative z-0">
        <slot />
      </main>

      <!-- Footer -->
      <Footer />
    </div>

    <!-- Back to Top Button -->
    <button 
      id="back-to-top"
      class="fixed bottom-6 right-6 p-3 z-[100] bg-slate-850/90 hover:bg-slate-800/90 backdrop-blur-sm border border-slate-700/50 rounded-full shadow-lg transition-all duration-300 opacity-0 translate-y-2 pointer-events-none group"
      aria-label="Back to top"
    >
      <svg 
        class="w-5 h-5 mx-auto text-gray-300 group-hover:text-white transition-colors duration-200" 
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
      >
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18"></path>
      </svg>
    </button>

    <script is:inline>
      // Constellation-style starfield background
      class ConstellationBackground {
        constructor() {
          this.canvas = document.getElementById('constellation-canvas');
          this.ctx = this.canvas.getContext('2d');
          this.bgColor = this.getBackgroundColor();
          this.stars = [];
          this.shootingStars = [];
          this.time = 0;

          this.resize();
          this.createStars();
          this.bindEvents();
          this.animate();
        }

        getBackgroundColor() {
          const bgColor = getComputedStyle(document.documentElement)
            .getPropertyValue('--bg-primary')
            .trim();
          return bgColor || '#0f172a';
        }

        getAccentColor() {
          const accentColor = getComputedStyle(document.documentElement)
            .getPropertyValue('--accent-primary')
            .trim() || 'rgb(59, 130, 246)';

          let r, g, b;
          if (accentColor.startsWith('oklch')) {
            r = 59; g = 130; b = 246;
          } else if (accentColor.startsWith('#')) {
            const hex = accentColor.slice(1);
            r = parseInt(hex.slice(0, 2), 16);
            g = parseInt(hex.slice(2, 4), 16);
            b = parseInt(hex.slice(4, 6), 16);
          } else if (accentColor.startsWith('rgb')) {
            const matches = accentColor.match(/\d+/g);
            r = parseInt(matches[0]);
            g = parseInt(matches[1]);
            b = parseInt(matches[2]);
          } else {
            r = 59; g = 130; b = 246;
          }

          return { r, g, b };
        }

        resize() {
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;
        }

        createStars() {
          this.stars = [];
          const density = (this.canvas.width * this.canvas.height) / 15000;
          const count = Math.min(220, Math.floor(density));

          for (let i = 0; i < count; i++) {
            this.stars.push({
              x: Math.random() * this.canvas.width,
              y: Math.random() * this.canvas.height,
              radius: 0.5 + Math.random() * 1.3,
              baseOpacity: 0.2 + Math.random() * 0.4,
              twinkleSpeed: 0.001 + Math.random() * 0.003,
              twinklePhase: Math.random() * Math.PI * 2,
            });
          }
        }

        bindEvents() {
          window.addEventListener('resize', () => {
            this.resize();
            this.createStars();
          });
        }

        spawnShootingStar() {
          const chance = 0.004; // rare
          if (Math.random() > chance) return;

          const fromTop = Math.random() < 0.5;
          const startX = fromTop ? Math.random() * this.canvas.width : -80;
          const startY = fromTop ? -40 : Math.random() * this.canvas.height * 0.4;
          const angle = fromTop ? (Math.PI / 2 + (Math.random() - 0.5) * 0.6) : (Math.PI / 4 + Math.random() * 0.4);
          const speed = 0.4 + Math.random() * 0.4;

          this.shootingStars.push({
            x: startX,
            y: startY,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1,
          });
        }

        update() {
          this.time += 16;

          // Twinkle stars
          this.stars.forEach(star => {
            const twinkle = Math.sin(this.time * star.twinkleSpeed + star.twinklePhase) * 0.2;
            star.opacity = Math.max(0, star.baseOpacity + twinkle);
          });

          // Shooting stars
          this.spawnShootingStar();
          this.shootingStars = this.shootingStars.filter(star => {
            star.x += star.vx;
            star.y += star.vy;
            star.life -= 0.008;
            return star.life > 0 && star.x < this.canvas.width + 100 && star.y < this.canvas.height + 100;
          });
        }

        drawStars() {
          const accent = this.getAccentColor();

          this.stars.forEach(star => {
            this.ctx.beginPath();
            this.ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
            this.ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
            this.ctx.fill();

            // Subtle accent glow
            this.ctx.beginPath();
            this.ctx.arc(star.x, star.y, star.radius * 2.5, 0, Math.PI * 2);
            this.ctx.fillStyle = `rgba(${accent.r}, ${accent.g}, ${accent.b}, ${star.opacity * 0.15})`;
            this.ctx.fill();
          });
        }

        drawConstellationLines() {
          const accent = this.getAccentColor();
          this.ctx.strokeStyle = `rgba(${accent.r}, ${accent.g}, ${accent.b}, 0.2)`;
          this.ctx.lineWidth = 0.5;

          const maxDistance = 130;

          for (let i = 0; i < this.stars.length; i++) {
            for (let j = i + 1; j < this.stars.length; j++) {
              const dx = this.stars[i].x - this.stars[j].x;
              const dy = this.stars[i].y - this.stars[j].y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < maxDistance) {
                const opacity = (1 - dist / maxDistance) * 0.12;
                this.ctx.strokeStyle = `rgba(${accent.r}, ${accent.g}, ${accent.b}, ${opacity})`;
                this.ctx.beginPath();
                this.ctx.moveTo(this.stars[i].x, this.stars[i].y);
                this.ctx.lineTo(this.stars[j].x, this.stars[j].y);
                this.ctx.stroke();
              }
            }
          }
        }

        drawShootingStars() {
          const accent = this.getAccentColor();
          this.shootingStars.forEach(star => {
            const length = 40;
            const tailX = star.x - star.vx * length;
            const tailY = star.y - star.vy * length;

            const gradient = this.ctx.createLinearGradient(star.x, star.y, tailX, tailY);
            gradient.addColorStop(0, `rgba(${accent.r}, ${accent.g}, ${accent.b}, ${0.8 * star.life})`);
            gradient.addColorStop(1, `rgba(${accent.r}, ${accent.g}, ${accent.b}, 0)`);

            this.ctx.strokeStyle = gradient;
            this.ctx.lineWidth = 1.2;
            this.ctx.beginPath();
            this.ctx.moveTo(star.x, star.y);
            this.ctx.lineTo(tailX, tailY);
            this.ctx.stroke();

            // Bright head
            this.ctx.beginPath();
            this.ctx.arc(star.x, star.y, 2.5, 0, Math.PI * 2);
            this.ctx.fillStyle = `rgba(${accent.r}, ${accent.g}, ${accent.b}, ${0.9 * star.life})`;
            this.ctx.fill();
          });
        }

        animate() {
          this.ctx.fillStyle = this.bgColor;
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          this.update();
          this.drawStars();
          this.drawConstellationLines();
          this.drawShootingStars();

          requestAnimationFrame(() => this.animate());
        }
      }

      // Back to Top Button Functionality
      function initBackToTop() {
        const backToTopBtn = document.getElementById('back-to-top');
        if (!backToTopBtn) return;

        function toggleButtonVisibility() {
          const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
          
          if (scrollTop > 300) {
            backToTopBtn.classList.remove('opacity-0', 'translate-y-2', 'pointer-events-none');
            backToTopBtn.classList.add('opacity-100', 'translate-y-0');
          } else {
            backToTopBtn.classList.add('opacity-0', 'translate-y-2', 'pointer-events-none');
            backToTopBtn.classList.remove('opacity-100', 'translate-y-0');
          }
        }

        function scrollToTop() {
          window.scrollTo({
            top: 0,
            behavior: 'smooth'
          });
        }

        window.addEventListener('scroll', toggleButtonVisibility);
        backToTopBtn.addEventListener('click', scrollToTop);
        toggleButtonVisibility();
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          new ConstellationBackground();
          initBackToTop();
        });
      } else {
        new ConstellationBackground();
        initBackToTop();
      }
    </script>
  </body>
</html>

<style is:global>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  html, body {
    font-family: -apple-system, BlinkMacSystemFont, Inter, system-ui, sans-serif;
    overflow-x: hidden;
  }
  
  body {
    background: var(--bg-primary);
    min-height: 100vh;
  }
  
  /* Text selection highlight color */
  ::selection {
    background-color: var(--accent-primary);
    color: var(--text-primary);
  }
  
  ::-moz-selection {
    background-color: var(--accent-primary);
    color: var(--text-primary);
  }
</style>
