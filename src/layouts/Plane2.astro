---
import SpeedInsights from '@vercel/speed-insights/astro';

interface Props {
	title: string;
	description?: string;
}
const { title, description } = Astro.props;
---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="description" content={description} />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<link rel="icon" type="image/png" href="/favicon.png" sizes="512x512" />
		<meta name="generator" content={Astro.generator} />
		<title>{title} | {description}</title>
	</head>
	<body class="text-white min-h-screen relative overflow-hidden flex flex-col">
		<canvas id="neural-canvas" class="fixed top-0 left-0 w-full h-full -z-10"></canvas>

		<SpeedInsights />
		
		<!-- Page Content -->
		<div class="relative z-10 flex-grow flex flex-col">
			<slot />
		</div>
		
		<script is:inline>
			// Dynamic Neural Network Animation System
			class DynamicNeuralNetwork {
				constructor() {
					this.canvas = document.getElementById('neural-canvas');
					this.ctx = this.canvas.getContext('2d');
					this.time = 0;
					this.nodes = [];
					this.connections = [];
					this.pulses = [];
					this.mouseX = 0;
					this.mouseY = 0;

					// Paper airplane system
					this.planes = [];
					this.nextPlaneTime = 0; // ms
					this.planeImgLoaded = false;
					this.planeImg = new Image();
					this.planeImg.onload = () => { this.planeImgLoaded = true; };
					this.planeImg.src = '/paperplane.svg';
					
					this.resize();
					this.createNetwork();
					this.bindEvents();
					this.animate();
				}
				
				resize() {
					this.canvas.width = window.innerWidth;
					this.canvas.height = window.innerHeight;
				}
				
				createNetwork() {
					this.nodes = [];
					this.connections = [];
					
					// Create nodes in a loose grid with lots of variation
					const cols = Math.floor(this.canvas.width / 100) + 1;
					const rows = Math.floor(this.canvas.height / 80) + 1;
					
					// Create base nodes
					for (let row = 0; row < rows; row++) {
						for (let col = 0; col < cols; col++) {
							// Skip some nodes randomly to break the grid
							if (Math.random() < 0.3) continue;
							
							const baseX = (col * this.canvas.width) / (cols - 1);
							const baseY = (row * this.canvas.height) / (rows - 1);
							
							// Add significant randomness to break grid pattern
							const offsetX = (Math.random() - 0.5) * 80;
							const offsetY = (Math.random() - 0.5) * 60;
							
							this.nodes.push({
								x: baseX + offsetX,
								y: baseY + offsetY,
								originalX: baseX + offsetX,
								originalY: baseY + offsetY,
								size: 0.8 + Math.random() * 2, // Smaller nodes
								intensity: 0,
								maxIntensity: 0.2 + Math.random() * 0.3, // Less bright
								pulsePhase: Math.random() * Math.PI * 2,
								activity: 0,
								maxActivity: 0.4 + Math.random() * 0.2, // Reduced activity
								
								// Fade in/out properties
								fadeState: Math.random() < 0.7 ? 'visible' : 'hidden', // Start most visible
								fadeTimer: Math.random() * 5000, // Random initial timer
								fadeDuration: 2000 + Math.random() * 3000, // 2-5 seconds to fade
								nextFadeDelay: 1000 + Math.random() * 8000, // 1-9 seconds between fades
								
								// Floating properties
								floatAmplitude: 5 + Math.random() * 10,
								floatSpeed: 0.0005 + Math.random() * 0.001,
								
								row: row,
								col: col,
								alive: true
							});
						}
					}
					
					// Add some completely random nodes to fill gaps
					const randomNodeCount = Math.floor(this.nodes.length * 0.3);
					for (let i = 0; i < randomNodeCount; i++) {
						this.nodes.push({
							x: Math.random() * this.canvas.width,
							y: Math.random() * this.canvas.height,
							originalX: Math.random() * this.canvas.width,
							originalY: Math.random() * this.canvas.height,
							size: 1 + Math.random() * 3,
							intensity: 0,
							maxIntensity: 0.3 + Math.random() * 0.4,
							pulsePhase: Math.random() * Math.PI * 2,
							activity: 0,
							maxActivity: 0.5 + Math.random() * 0.3,
							
							fadeState: Math.random() < 0.5 ? 'visible' : 'hidden',
							fadeTimer: Math.random() * 5000,
							fadeDuration: 1500 + Math.random() * 2500,
							nextFadeDelay: 2000 + Math.random() * 6000,
							
							floatAmplitude: 3 + Math.random() * 8,
							floatSpeed: 0.0008 + Math.random() * 0.0012,
							
							row: -1,
							col: -1,
							alive: true
						});
					}
					
					// Create dynamic connections
					this.updateConnections();
				}
				
				updateConnections() {
					this.connections = [];
					
					// Only connect visible nodes
					const visibleNodes = this.nodes.filter(node => 
						node.alive && (node.fadeState === 'visible' || node.fadeState === 'fading-in')
					);
					
					visibleNodes.forEach((node, i) => {
						visibleNodes.forEach((otherNode, j) => {
							if (i !== j) {
								const dx = node.x - otherNode.x;
								const dy = node.y - otherNode.y;
								const distance = Math.sqrt(dx * dx + dy * dy);
								
								// Connect closer nodes with higher probability
								if (distance < 120 && Math.random() > 0.6) {
									this.connections.push({
										start: this.nodes.indexOf(node),
										end: this.nodes.indexOf(otherNode),
										strength: 0,
										baseStrength: 0.05 + Math.random() * 0.25,
										pulseSpeed: 0.008 + Math.random() * 0.015,
										distance: distance,
										maxStrength: 0.3 + Math.random() * 0.4
									});
								}
							}
						});
					});
				}
				
				// Find nearby nodes for connections
				findNearbyNodes(nodeIndex) {
					const node = this.nodes[nodeIndex];
					const nearby = [];
					const maxDistance = 80; // Connection range
					
					for (let i = 0; i < this.nodes.length; i++) {
						if (i === nodeIndex) continue;
						
						const other = this.nodes[i];
						const dx = node.x - other.x;
						const dy = node.y - other.y;
						const distance = Math.sqrt(dx * dx + dy * dy);
						
						if (distance < maxDistance) {
							nearby.push({ index: i, distance });
						}
					}
					
					return nearby;
				}

				// Draw connections between nodes
				drawConnections() {
					for (let i = 0; i < this.nodes.length; i++) {
						const node = this.nodes[i];
						if (node.fadeState === 'hidden' || node.intensity < 0.1) continue;
						
						const nearby = this.findNearbyNodes(i);
						
						for (const { index, distance } of nearby) {
							const other = this.nodes[index];
							if (other.fadeState === 'hidden' || other.intensity < 0.1) continue;
							
							// Only draw if both nodes are reasonably visible
							const minIntensity = Math.min(node.intensity, other.intensity);
							if (minIntensity < 0.05) continue;
							
							// Fade connection based on node intensities and distance
							const alpha = (minIntensity * 0.15) * (1 - distance / 80);
							this.ctx.strokeStyle = `rgba(59, 130, 246, ${alpha})`;
							this.ctx.lineWidth = 5.5;
							
							this.ctx.beginPath();
							this.ctx.moveTo(node.x, node.y);
							this.ctx.lineTo(other.x, other.y);
							this.ctx.stroke();
						}
					}
				}
				
				bindEvents() {
					window.addEventListener('resize', () => {
						this.resize();
						this.createNetwork();
					});
					
					// this.canvas.addEventListener('mousemove', (e) => {
					// 	this.mouseX = e.clientX;
					// 	this.mouseY = e.clientY;
						
					// 	// Activate nodes near mouse and force them to be visible
					// 	this.nodes.forEach(node => {
					// 		if (!node.alive) return;
							
					// 		const dx = this.mouseX - node.x;
					// 		const dy = this.mouseY - node.y;
					// 		const distance = Math.sqrt(dx * dx + dy * dy);
							
					// 		if (distance < 80) {
					// 			const activation = Math.max(0, 1 - distance / 80);
					// 			node.activity = Math.min(node.maxActivity, node.activity + activation * 0.08);
								
					// 			// Force visibility when mouse is near
					// 			if (node.fadeState === 'hidden' || node.fadeState === 'fading-out') {
					// 				node.fadeState = 'fading-in';
					// 				node.fadeTimer = 0;
					// 			}
					// 		}
					// 	});
					// });
				}
				
				createPulse(startNodeIndex, endNodeIndex) {
					this.pulses.push({
						startNode: startNodeIndex,
						endNode: endNodeIndex,
						progress: 0,
						speed: 0.015 + Math.random() * 0.025,
						intensity: 0.5 + Math.random() * 0.5,
						life: 1.0
					});
				}

				// ========================
				// Paper airplane animation
				// ========================
				spawnPlane() {
					const w = this.canvas.width;
					const h = this.canvas.height;
					const margin = 80; // ensure fully off-screen spawn

					// Choose an edge to spawn from
					const edge = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
					let startX = 0, startY = 0;
					switch (edge) {
						case 0: startX = Math.random() * w; startY = -margin; break; // top
						case 1: startX = w + margin; startY = Math.random() * h; break; // right
						case 2: startX = Math.random() * w; startY = h + margin; break; // bottom
						case 3: startX = -margin; startY = Math.random() * h; break; // left
					}

					// Pick a target point inside the viewport to define a general forward direction
					const target = { x: Math.random() * w, y: Math.random() * h };
					let dirX = target.x - startX;
					let dirY = target.y - startY;
					const len = Math.hypot(dirX, dirY) || 1;
					dirX /= len; dirY /= len;

					// Motion parameters to produce true circular loops while progressing
					const loops = 1 + Math.floor(Math.random() * 3); // 1-3 loops
					const loopRadius = 30 + Math.random() * 60; // 30-90 px
					const centerStep = loopRadius * (1.0 + Math.random() * 1.2); // forward distance per loop
					const loopSpan = 0.6 + Math.random() * 0.25; // fraction of duration spent looping (60-85%)
					const cruiseDistance = Math.max(w, h) * (0.25 + Math.random() * 0.35); // extra straight travel after loops
					const totalForward = centerStep * loops + cruiseDistance;
					const duration = 8000 + Math.random() * 7000; // 8-15s for longer, calmer travel
					const startTime = this.time;
					const size = 12 + Math.random() * 10; // plane icon scale
					const loopEllipticity = 0.7 + Math.random() * 0.3; // 0.7-1.0
					const phase = Math.random() * Math.PI * 2;
					const fadeInMs = 800 + Math.random() * 600;  // 0.8-1.4s fade-in
					const fadeOutMs = 1000 + Math.random() * 800; // 1.0-1.8s fade-out

					const baseDir = { x: dirX, y: dirY };
					const perpDir = { x: -dirY, y: dirX };

					this.planes.push({
						start: { x: startX, y: startY },
						baseDir, perpDir,
						centerStep, totalForward,
						loops, loopRadius, loopEllipticity, phase,
						duration, startTime,
						loopSpan, cruiseDistance,
						fadeInMs, fadeOutMs,
						size,
						trail: [],
						lastPos: null,
						alpha: 0,
						cruiseInit: false,
						cruiseOrigin: null,
						cruiseDir: null
					});
				}

				updatePlanes() {
					// Spawn at random intervals (0.8s - 3.2s)
					if (this.time >= this.nextPlaneTime) {
						this.spawnPlane();
						// Occasionally spawn two at once for variety
						if (Math.random() < 0.2) this.spawnPlane();
						this.nextPlaneTime = this.time + 800 + Math.random() * 2400;
					}

					const now = this.time;
					this.planes = this.planes.filter(p => {
						const age = now - p.startTime;
						const t = Math.min(1, age / p.duration);

						// Fade in/out alpha
						const aIn = Math.min(1, age / p.fadeInMs);
						const aOut = Math.min(1, Math.max(0, (p.duration - age) / p.fadeOutMs));
						p.alpha = Math.max(0, Math.min(aIn, aOut));

						// Loop timing occupies only a portion of the duration
						const tLoop = Math.min(1, t / p.loopSpan);
						const theta = tLoop * p.loops * Math.PI * 2 + p.phase;
						const loopCountProgress = (theta - p.phase) / (Math.PI * 2); // 0..loops

						// Forward distance of the moving center
						const centerDistLoops = Math.min(loopCountProgress, p.loops) * p.centerStep;
						const cruiseProgress = t > p.loopSpan ? (t - p.loopSpan) / (1 - p.loopSpan) : 0;
						const centerDist = centerDistLoops + cruiseProgress * p.cruiseDistance;

						const cx = p.start.x + p.baseDir.x * centerDist;
						const cy = p.start.y + p.baseDir.y * centerDist;

						// Smooth amplitude envelope to avoid abrupt direction changes
						const clamp01 = v => Math.max(0, Math.min(1, v));
						const ease = v => v * v * (3 - 2 * v); // smoothstep
						const rampIn = ease(clamp01(tLoop / 0.15));
						const rampOut = ease(clamp01((1 - tLoop) / 0.28));
						const amp = rampIn * rampOut; // 0..1

						const offsetPerp = Math.cos(theta) * p.loopRadius * amp;
						const offsetAlong = Math.sin(theta) * p.loopRadius * p.loopEllipticity * amp;

						let x = cx + p.perpDir.x * offsetPerp + p.baseDir.x * offsetAlong;
						let y = cy + p.perpDir.y * offsetPerp + p.baseDir.y * offsetAlong;

						// If entering cruise, align cruise direction with last loop tangent
						if (!p.cruiseInit && t >= p.loopSpan) {
							// Tangent of the loop path in world space
							const dOffsetPerp_dTheta = -Math.sin(theta) * p.loopRadius * amp;
							const dOffsetAlong_dTheta =  Math.cos(theta) * p.loopRadius * p.loopEllipticity * amp;
							// d(theta)/dt in loop phase
							const dTheta_dt = (p.loops * Math.PI * 2) / (p.loopSpan * p.duration);
							const vxLoop = p.perpDir.x * dOffsetPerp_dTheta + p.baseDir.x * dOffsetAlong_dTheta;
							const vyLoop = p.perpDir.y * dOffsetPerp_dTheta + p.baseDir.y * dOffsetAlong_dTheta;
							let vx = p.baseDir.x * (p.centerStep / (p.loopSpan * p.duration)) + vxLoop * dTheta_dt;
							let vy = p.baseDir.y * (p.centerStep / (p.loopSpan * p.duration)) + vyLoop * dTheta_dt;
							const vlen = Math.hypot(vx, vy) || 1;
							p.cruiseDir = { x: vx / vlen, y: vy / vlen };
							p.cruiseOrigin = { x, y };
							p.cruiseInit = true;
						}

						// During cruise, move straight along the tangent direction from the last loop point
						if (p.cruiseInit) {
							const cruiseProgress = (t - p.loopSpan) / (1 - p.loopSpan);
							const dist = cruiseProgress * p.cruiseDistance;
							x = p.cruiseOrigin.x + p.cruiseDir.x * dist;
							y = p.cruiseOrigin.y + p.cruiseDir.y * dist;
						}

						// Orientation follows current velocity, smoothed to avoid jitter
						if (p.lastPos) {
							const newAngle = Math.atan2(y - p.lastPos.y, x - p.lastPos.x);
							if (typeof p.angle === 'number') {
								const twoPi = Math.PI * 2;
								let delta = (newAngle - p.angle + Math.PI) % twoPi; if (delta < 0) delta += twoPi; delta -= Math.PI;
								p.angle = p.angle + delta * 0.22; // smoothing factor
							} else {
								p.angle = newAngle;
							}
						}
						p.lastPos = { x, y };

						// Trail management
						p.trail.push({ x, y, time: now, alpha: p.alpha });
						if (p.trail.length > 180) p.trail.shift();

						// End when duration complete
						return t < 1;
					});
				}

				drawPlaneTrails() {
					this.ctx.save();
					this.ctx.lineWidth = 1.1;
					this.ctx.setLineDash([3, 5]);
					this.ctx.lineCap = 'round';
					this.planes.forEach(p => {
						if (p.trail.length < 2) return;
						for (let i = 1; i < p.trail.length; i++) {
							const a = p.trail[i - 1];
							const b = p.trail[i];
							const age = (this.time - b.time) / 4200; // fade newer point stronger
							const segAlpha = Math.max(0, 1 - age) * 0.45 * (b.alpha ?? p.alpha ?? 1);
							if (segAlpha <= 0.02) continue;
							this.ctx.strokeStyle = `rgba(255,255,255,${segAlpha})`;
							this.ctx.beginPath();
							this.ctx.moveTo(a.x, a.y);
							this.ctx.lineTo(b.x, b.y);
							this.ctx.stroke();
						}
					});
					this.ctx.setLineDash([]);
					this.ctx.restore();
				}

				drawPlanes() {
					if (!this.planeImgLoaded) return;
					this.planes.forEach(p => {
						const { x, y } = p.lastPos || p.start;
						const angle = p.angle || 0;
						const scale = p.size / 32; // Slightly smaller for delicacy

						this.ctx.save();
						this.ctx.globalAlpha = p.alpha ?? 1;
						this.ctx.translate(x, y);
						this.ctx.rotate(angle + (Math.PI * .9)); // rotate 180° to match SVG orientation
						this.ctx.scale(scale, scale);
						// Center the image around (0,0). The SVG is roughly square 58x58, we'll center by half.
						const iw = 58; const ih = 58;
						this.ctx.drawImage(this.planeImg, -iw * 0.5, -ih * 0.5, iw, ih);
						this.ctx.restore();
					});
				}
				
				updateNetwork() {
					const deltaTime = 16;
					
					// Update nodes
					this.nodes.forEach((node) => {
						if (!node.alive) return;
						
						// Update fade states
						node.fadeTimer += deltaTime;
						
						switch (node.fadeState) {
							case 'visible':
								node.intensity = Math.min(node.maxIntensity, node.intensity + 0.02);
								if (node.fadeTimer > node.nextFadeDelay) {
									if (Math.random() < 0.002) { // Random chance to start fading
										node.fadeState = 'fading-out';
										node.fadeTimer = 0;
									}
								}
								break;
								
							case 'fading-out':
								const fadeOutProgress = node.fadeTimer / node.fadeDuration;
								node.intensity = node.maxIntensity * (1 - fadeOutProgress);
								if (fadeOutProgress >= 1) {
									node.fadeState = 'hidden';
									node.fadeTimer = 0;
									node.intensity = 0;
									node.nextFadeDelay = 1000 + Math.random() * 8000;
								}
								break;
								
							case 'hidden':
								node.intensity = 0;
								if (node.fadeTimer > node.nextFadeDelay) {
									if (Math.random() < 0.003) { // Random chance to start appearing
										node.fadeState = 'fading-in';
										node.fadeTimer = 0;
									}
								}
								break;
								
							case 'fading-in':
								const fadeInProgress = node.fadeTimer / node.fadeDuration;
								node.intensity = node.maxIntensity * fadeInProgress;
								if (fadeInProgress >= 1) {
									node.fadeState = 'visible';
									node.fadeTimer = 0;
									node.intensity = node.maxIntensity;
									node.nextFadeDelay = 3000 + Math.random() * 10000;
								}
								break;
						}
						
						// Natural activity decay
						node.activity *= 0.992;
						
						// Random bursts of activity
						if (node.fadeState === 'visible' && Math.random() < 0.0008) {
							node.activity = Math.min(node.maxActivity, node.activity + Math.random() * 0.4);
						}
						
						// Enhanced floating motion
						node.x = node.originalX + 
							Math.sin(this.time * node.floatSpeed + node.pulsePhase) * node.floatAmplitude;
						node.y = node.originalY + 
							Math.cos(this.time * node.floatSpeed * 0.7 + node.pulsePhase) * node.floatAmplitude * 0.6;
					});
					
					// Periodically update connections as nodes fade in/out
					if (this.time % 1000 < 16) {
						this.updateConnections();
					}
					
					// Update connections
					this.connections.forEach(connection => {
						const startNode = this.nodes[connection.start];
						const endNode = this.nodes[connection.end];
						
						if (!startNode || !endNode || !startNode.alive || !endNode.alive) return;
						
						// Connection strength based on both nodes being visible and active
						const visibilityFactor = Math.min(startNode.intensity, endNode.intensity);
						const avgActivity = (startNode.activity + endNode.activity) / 2;
						connection.strength = connection.baseStrength * visibilityFactor * (0.3 + avgActivity);
						
						// Create pulses along active connections
						if (connection.strength > 0.15 && Math.random() < 0.004) {
							this.createPulse(connection.start, connection.end);
						}
					});
					
					// Update pulses
					this.pulses = this.pulses.filter(pulse => {
						pulse.progress += pulse.speed;
						pulse.life *= 0.985;
						
						if (pulse.progress >= 1) {
							const endNode = this.nodes[pulse.endNode];
							if (endNode && endNode.alive) {
								endNode.activity = Math.min(endNode.maxActivity, endNode.activity + pulse.intensity * 0.3);
							}
							return false;
						}
						
						return pulse.life > 0.1;
					});
				}
				
				drawNetwork() {
					// Draw simple connections between nearby nodes
					this.drawConnections();
					
					// Draw nodes
					this.nodes.forEach(node => {
						if (!node.alive || node.intensity < 0.01) return;
						
						const totalBrightness = node.intensity + node.activity;
						const pulseEffect = 1 + Math.sin(this.time * 0.002 + node.pulsePhase) * 0.15; // Reduced pulse
						
						// Node glow (smaller and dimmer)
						this.ctx.beginPath();
						this.ctx.arc(node.x, node.y, node.size * 1.8 * pulseEffect, 0, Math.PI * 2);
						this.ctx.fillStyle = `rgba(100, 200, 255, ${totalBrightness * 0.08})`;
						this.ctx.fill();
						
						// Node core
						this.ctx.beginPath();
						this.ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2);
						this.ctx.fillStyle = `rgba(200, 230, 255, ${totalBrightness * 0.6})`; // Dimmer
						this.ctx.fill();
						
						// Bright center for very active nodes (dimmer)
						if (node.activity > 0.3) {
							this.ctx.beginPath();
							this.ctx.arc(node.x, node.y, node.size * 0.3, 0, Math.PI * 2);
							this.ctx.fillStyle = `rgba(255, 255, 255, ${node.activity * 0.4})`;
							this.ctx.fill();
						}
					});
				}
				
				animate() {
					this.time += 16;
					
					// Clear canvas with dark background
					// this.ctx.fillStyle = 'rgba(2, 6, 23, 0.95)';
					this.ctx.fillStyle = '#0f172a';
					this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
					
					// Update and draw the neural network
					this.updateNetwork();
					this.drawNetwork();

					// Update and draw paper planes
					this.updatePlanes();
					this.drawPlaneTrails();
					this.drawPlanes();
					
					requestAnimationFrame(() => this.animate());
				}
			}
			
			// Initialize when DOM is loaded
			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', () => new DynamicNeuralNetwork());
			} else {
				new DynamicNeuralNetwork();
			}
		</script>
	</body>
</html>

<style is:global>
	* {
		margin: 0;
		padding: 0;
		box-sizing: border-box;
	}
	
	html, body {
		font-family: system-ui, sans-serif;
		overflow-x: hidden;
	}
	
	body {
		/* background: linear-gradient(135deg, #170202 0%, #0f172a 50%, #1e293b 100%); */
		background: #0f172a;
		min-height: 100vh;
	}
	
	/* Text selection highlight color */
	::selection {
		background-color: #828FA4;
		color: #0f172a;
	}
	
	::-moz-selection {
		background-color: #828FA4;
		color: #0f172a;
	}
</style>
