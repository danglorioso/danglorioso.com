---
import SpeedInsights from '@vercel/speed-insights/astro';

interface Props {
	title: string;
	description?: string;
}
const { title, description } = Astro.props;
---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="description" content={description} />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<link rel="icon" type="image/png" href="/favicon.png" sizes="512x512" />
		<meta name="generator" content={Astro.generator} />
		<title>{title}</title>
	</head>
	<body class="bg-slate-900 text-white min-h-screen relative overflow-hidden">
		<!-- Animated Neural Network Canvas Background -->
		<canvas id="neural-canvas" class="fixed top-0 left-0 w-full h-full -z-10"></canvas>

		<SpeedInsights />
		
		<script is:inline>
			// Neural Network Animation System
			class NeuralNetwork {
				constructor() {
					this.canvas = document.getElementById('neural-canvas');
					this.ctx = this.canvas.getContext('2d');
					this.time = 0;
					this.nodes = [];
					this.connections = [];
					this.pulses = [];
					this.mouseX = 0;
					this.mouseY = 0;
					
					this.resize();
					this.createNetwork();
					this.bindEvents();
					this.animate();
				}
				
				resize() {
					this.canvas.width = window.innerWidth;
					this.canvas.height = window.innerHeight;
				}
				
				createNetwork() {
					this.nodes = [];
					this.connections = [];
					
					// Create a grid-based neural network structure
					const cols = Math.floor(this.canvas.width / 120) + 2;
					const rows = Math.floor(this.canvas.height / 100) + 2;
					
					// Create nodes in a slightly irregular grid
					for (let row = 0; row < rows; row++) {
						for (let col = 0; col < cols; col++) {
							const baseX = (col * this.canvas.width) / (cols - 1);
							const baseY = (row * this.canvas.height) / (rows - 1);
							
							// Add some randomness to make it look more organic
							const offsetX = (Math.random() - 0.5) * 40;
							const offsetY = (Math.random() - 0.5) * 40;
							
							this.nodes.push({
								x: baseX + offsetX,
								y: baseY + offsetY,
								originalX: baseX + offsetX,
								originalY: baseY + offsetY,
								size: 2 + Math.random() * 4,
								intensity: 0.3 + Math.random() * 0.4,
								pulsePhase: Math.random() * Math.PI * 2,
								activity: 0,
								maxActivity: 0.8 + Math.random() * 0.2,
								row: row,
								col: col
							});
						}
					}
					
					// Create connections between nearby nodes
					this.nodes.forEach((node, i) => {
						this.nodes.forEach((otherNode, j) => {
							if (i !== j) {
								const dx = node.x - otherNode.x;
								const dy = node.y - otherNode.y;
								const distance = Math.sqrt(dx * dx + dy * dy);
								
								// Connect nodes that are reasonably close
								if (distance < 150 && Math.random() > 0.4) {
									this.connections.push({
										start: i,
										end: j,
										strength: 0,
										baseStrength: 0.1 + Math.random() * 0.3,
										pulseSpeed: 0.01 + Math.random() * 0.02,
										distance: distance
									});
								}
							}
						});
					});
				}
				
				bindEvents() {
					window.addEventListener('resize', () => {
						this.resize();
						this.createNetwork();
					});
					
					this.canvas.addEventListener('mousemove', (e) => {
						this.mouseX = e.clientX;
						this.mouseY = e.clientY;
						
						// Activate nodes near mouse
						this.nodes.forEach(node => {
							const dx = this.mouseX - node.x;
							const dy = this.mouseY - node.y;
							const distance = Math.sqrt(dx * dx + dy * dy);
							
							if (distance < 100) {
								const activation = Math.max(0, 1 - distance / 100);
								node.activity = Math.min(node.maxActivity, node.activity + activation * 0.05);
							}
						});
					});
				}
				
				createPulse(startNode, endNode) {
					this.pulses.push({
						startNode: startNode,
						endNode: endNode,
						progress: 0,
						speed: 0.02 + Math.random() * 0.03,
						intensity: 0.6 + Math.random() * 0.4,
						life: 1.0
					});
				}
				
				updateNetwork() {
					// Update node activities
					this.nodes.forEach(node => {
						// Natural decay
						node.activity *= 0.995;
						
						// Random activation
						if (Math.random() < 0.001) {
							node.activity = Math.min(node.maxActivity, node.activity + Math.random() * 0.3);
						}
						
						// Gentle floating motion
						node.x = node.originalX + Math.sin(this.time * 0.0008 + node.pulsePhase) * 3;
						node.y = node.originalY + Math.cos(this.time * 0.0006 + node.pulsePhase) * 2;
					});
					
					// Update connections and create pulses
					this.connections.forEach(connection => {
						const startNode = this.nodes[connection.start];
						const endNode = this.nodes[connection.end];
						
						// Connection strength based on node activities
						const avgActivity = (startNode.activity + endNode.activity) / 2;
						connection.strength = connection.baseStrength * (0.2 + avgActivity);
						
						// Occasionally create pulses along active connections
						if (startNode.activity > 0.3 && Math.random() < 0.005) {
							this.createPulse(connection.start, connection.end);
						}
					});
					
					// Update pulses
					this.pulses = this.pulses.filter(pulse => {
						pulse.progress += pulse.speed;
						pulse.life *= 0.98;
						
						// Activate end node when pulse arrives
						if (pulse.progress >= 1) {
							const endNode = this.nodes[pulse.endNode];
							endNode.activity = Math.min(endNode.maxActivity, endNode.activity + pulse.intensity * 0.2);
							return false;
						}
						
						return pulse.life > 0.1;
					});
				}
				
				drawNetwork() {
					// Draw connections
					this.connections.forEach(connection => {
						if (connection.strength > 0.05) {
							const startNode = this.nodes[connection.start];
							const endNode = this.nodes[connection.end];
							
							this.ctx.strokeStyle = `rgba(100, 200, 255, ${connection.strength})`;
							this.ctx.lineWidth = 0.5 + connection.strength * 2;
							this.ctx.beginPath();
							this.ctx.moveTo(startNode.x, startNode.y);
							this.ctx.lineTo(endNode.x, endNode.y);
							this.ctx.stroke();
						}
					});
					
					// Draw pulses
					this.pulses.forEach(pulse => {
						const startNode = this.nodes[pulse.startNode];
						const endNode = this.nodes[pulse.endNode];
						
						const x = startNode.x + (endNode.x - startNode.x) * pulse.progress;
						const y = startNode.y + (endNode.y - startNode.y) * pulse.progress;
						
						const opacity = pulse.intensity * pulse.life;
						
						// Pulse glow
						this.ctx.beginPath();
						this.ctx.arc(x, y, 4, 0, Math.PI * 2);
						this.ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
						this.ctx.fill();
						
						// Pulse trail
						this.ctx.beginPath();
						this.ctx.arc(x, y, 8, 0, Math.PI * 2);
						this.ctx.fillStyle = `rgba(100, 200, 255, ${opacity * 0.3})`;
						this.ctx.fill();
					});
					
					// Draw nodes
					this.nodes.forEach(node => {
						const brightness = node.intensity + node.activity;
						const pulseEffect = 1 + Math.sin(this.time * 0.003 + node.pulsePhase) * 0.2;
						
						// Node glow
						this.ctx.beginPath();
						this.ctx.arc(node.x, node.y, node.size * 2 * pulseEffect, 0, Math.PI * 2);
						this.ctx.fillStyle = `rgba(100, 200, 255, ${brightness * 0.2})`;
						this.ctx.fill();
						
						// Node core
						this.ctx.beginPath();
						this.ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2);
						this.ctx.fillStyle = `rgba(200, 230, 255, ${brightness})`;
						this.ctx.fill();
						
						// Bright center for active nodes
						if (node.activity > 0.2) {
							this.ctx.beginPath();
							this.ctx.arc(node.x, node.y, node.size * 0.5, 0, Math.PI * 2);
							this.ctx.fillStyle = `rgba(255, 255, 255, ${node.activity})`;
							this.ctx.fill();
						}
					});
				}
				
				animate() {
					this.time += 16;
					
					// Clear canvas with dark gradient background
					const gradient = this.ctx.createRadialGradient(
						this.canvas.width / 2, this.canvas.height / 2, 0,
						this.canvas.width / 2, this.canvas.height / 2, Math.max(this.canvas.width, this.canvas.height)
					);
					gradient.addColorStop(0, '#1e293b'); // slate-800
					gradient.addColorStop(0.7, '#0f172a'); // slate-900
					gradient.addColorStop(1, '#020617'); // slate-950
					
					this.ctx.fillStyle = gradient;
					this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
					
					// Update and draw the neural network
					this.updateNetwork();
					this.drawNetwork();
					
					requestAnimationFrame(() => this.animate());
				}
			}
			
			// Initialize when DOM is loaded
			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', () => new NeuralNetwork());
			} else {
				new NeuralNetwork();
			}
		</script>
	</body>
</html>

<style is:global>
	* {
		margin: 0;
		padding: 0;
		box-sizing: border-box;
	}
	
	html, body {
		font-family: system-ui, sans-serif;
		overflow-x: hidden;
	}
	
	body {
		background: radial-gradient(circle at center, #1e293b 0%, #0f172a 70%, #020617 100%);
		min-height: 100vh;
	}

	/* Custom scrollbar for webkit browsers */
	::-webkit-scrollbar {
		width: 8px;
	}
	
	::-webkit-scrollbar-track {
		background: #1e293b;
	}
	
	::-webkit-scrollbar-thumb {
		background: #475569;
		border-radius: 4px;
	}
	
	::-webkit-scrollbar-thumb:hover {
		background: #64748b;
	}

	/* Responsive adjustments */
	@media (max-width: 1024px) {
		main {
			flex-direction: column;
			align-items: center;
			text-align: center;
		}
		
		.flex-1.max-w-lg.ml-16 {
			margin-left: 0;
			margin-top: 3rem;
			max-width: 100%;
		}
	}
	
	@media (max-width: 768px) {
		nav {
			padding-top: 1.5rem;
			padding-bottom: 2rem;
		}
		
		nav > div {
			flex-wrap: wrap;
			gap: 1rem;
			padding: 0.75rem 1.5rem;
		}
		
		h1 {
			font-size: 4rem !important;
		}
		
		.bg-slate-300 span {
			font-size: 3rem !important;
		}
	}
</style>
