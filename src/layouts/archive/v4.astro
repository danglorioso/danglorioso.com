---
import SpeedInsights from "@vercel/speed-insights/astro";

interface Props {
  title: string;
  description?: string;
}
const { title, description } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content={description} />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="icon" type="image/png" href="/favicon.png" sizes="512x512" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
  </head>
  <body
    class="bg-slate-950/95 text-white min-h-screen relative overflow-hidden"
  >
    <!-- Particle Canvas Background -->
    <canvas id="particle-canvas" class="fixed top-0 left-0 w-full h-full -z-10"
    ></canvas>

    <SpeedInsights />

    <script is:inline>
      // Particle System
      class ParticleSystem {
        constructor() {
          this.canvas = document.getElementById("particle-canvas");
          this.ctx = this.canvas.getContext("2d");
          this.particles = [];
          this.mouseX = 0;
          this.mouseY = 0;
          this.time = 0;

          this.resize();
          this.createParticles();
          this.bindEvents();
          this.animate();
        }

        resize() {
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;
        }

        createParticles() {
          const particleCount = Math.min(
            4,
            Math.floor((this.canvas.width * this.canvas.height) / 100000)
          );

          for (let i = 0; i < particleCount; i++) {
            this.particles.push(this.createShootingStar());
          }
        }

        createShootingStar() {
          // Create curved flight paths like airplanes
          const startX = -50 + Math.random() * (this.canvas.width + 100);
          const startY = -50 + Math.random() * (this.canvas.height + 100);

          // Create a destination point for curved path
          const destX = -50 + Math.random() * (this.canvas.width + 100);
          const destY = -50 + Math.random() * (this.canvas.height + 100);

          // Control point for curve (creates arc)
          const controlX = (startX + destX) / 2 + (Math.random() - 0.5) * 200;
          const controlY = (startY + destY) / 2 + (Math.random() - 0.5) * 200;

          return {
            x: startX,
            y: startY,
            startX: startX,
            startY: startY,
            controlX: controlX,
            controlY: controlY,
            destX: destX,
            destY: destY,
            progress: 0,
            speed: 0.0008 + Math.random() * 0.0015, // Much slower max speed
            size: Math.random() * 0.8 + 0.6, // Smaller, more realistic
            opacity: 0.7 + Math.random() * 0.3,
            trail: [],
            maxTrailLength: 12 + Math.random() * 8, // Longer trails
            life: 1.0,
            fadeRate: 0.0005 + Math.random() * 0.0008, // Much slower fade
            // Blinking properties
            blinkPhase: Math.random() * Math.PI * 2,
            blinkSpeed: 0.003 + Math.random() * 0.002,
            isBlinking: true,
          };
        }

        bindEvents() {
          window.addEventListener("resize", () => {
            this.resize();
            this.particles = [];
            this.createParticles();
          });

          this.canvas.addEventListener("mousemove", (e) => {
            this.mouseX = e.clientX;
            this.mouseY = e.clientY;
          });
        }

        // Quadratic Bezier curve interpolation for curved paths
        getBezierPoint(t, start, control, end) {
          const invT = 1 - t;
          return {
            x: invT * invT * start.x + 2 * invT * t * control.x + t * t * end.x,
            y: invT * invT * start.y + 2 * invT * t * control.y + t * t * end.y,
          };
        }

        updateParticle(particle) {
          // Update progress along curved path
          particle.progress += particle.speed;

          // Calculate position on Bezier curve
          const position = this.getBezierPoint(
            particle.progress,
            { x: particle.startX, y: particle.startY },
            { x: particle.controlX, y: particle.controlY },
            { x: particle.destX, y: particle.destY }
          );

          // Add current position to trail
          particle.trail.push({
            x: particle.x,
            y: particle.y,
            opacity: particle.life,
          });

          // Update position
          particle.x = position.x;
          particle.y = position.y;

          // Limit trail length
          if (particle.trail.length > particle.maxTrailLength) {
            particle.trail.shift();
          }

          // Update blinking (airplane navigation lights)
          particle.currentBlink =
            0.3 +
            0.7 *
              Math.abs(
                Math.sin(this.time * particle.blinkSpeed + particle.blinkPhase)
              );

          // Fade out over time (much slower)
          particle.life -= particle.fadeRate;

          // Reset if progress complete or faded out
          if (particle.progress >= 1 || particle.life <= 0) {
            // Create new airplane path
            const newStar = this.createShootingStar();
            Object.assign(particle, newStar);
          }
        }

        drawParticles() {
          this.particles.forEach((particle) => {
            // Draw trail (more persistent and subtle)
            if (particle.trail.length > 1) {
              for (let i = 1; i < particle.trail.length; i++) {
                const current = particle.trail[i];
                const previous = particle.trail[i - 1];
                const trailOpacity =
                  (i / particle.trail.length) * particle.life * 0.08;

                this.ctx.strokeStyle = `rgba(148, 163, 184, ${trailOpacity})`;
                this.ctx.lineWidth = 0.5;
                this.ctx.beginPath();
                this.ctx.moveTo(previous.x, previous.y);
                this.ctx.lineTo(current.x, current.y);
                this.ctx.stroke();
              }
            }

            // Draw airplane light with blinking
            const finalOpacity =
              particle.opacity * particle.life * particle.currentBlink;

            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            this.ctx.fillStyle = `rgba(148, 163, 184, ${finalOpacity})`;
            this.ctx.fill();

            // Add a very subtle glow (no dramatic effects)
            this.ctx.beginPath();
            this.ctx.arc(
              particle.x,
              particle.y,
              particle.size * 1.5,
              0,
              Math.PI * 2
            );
            this.ctx.fillStyle = `rgba(148, 163, 184, ${finalOpacity * 0.2})`;
            this.ctx.fill();
          });
        }

        animate() {
          this.time += 16;

          // Clear completely (no trail effect)
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // Update and draw particles only (no connections)
          this.particles.forEach((particle) => this.updateParticle(particle));
          this.drawParticles();

          requestAnimationFrame(() => this.animate());
        }
      }

      // Initialize when DOM is loaded
      if (document.readyState === "loading") {
        document.addEventListener(
          "DOMContentLoaded",
          () => new ParticleSystem()
        );
      } else {
        new ParticleSystem();
      }
    </script>
  </body>
</html>

<style is:global>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html,
  body {
    font-family: system-ui, sans-serif;
    overflow-x: hidden;
  }

  body {
    background: linear-gradient(180deg, #020617 0%, #0f172a 50%, #1e293b 100%);
    min-height: 100vh;
  }

  /* Custom scrollbar for webkit browsers */
  ::-webkit-scrollbar {
    width: 8px;
  }

  ::-webkit-scrollbar-track {
    background: #1e293b;
  }

  ::-webkit-scrollbar-thumb {
    background: #475569;
    border-radius: 4px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background: #64748b;
  }

  /* Responsive adjustments */
  @media (max-width: 1024px) {
    main {
      flex-direction: column;
      align-items: center;
      text-align: center;
    }

    .flex-1.max-w-lg.ml-16 {
      margin-left: 0;
      margin-top: 3rem;
      max-width: 100%;
    }
  }

  @media (max-width: 768px) {
    nav {
      padding-top: 1.5rem;
      padding-bottom: 2rem;
    }

    nav > div {
      flex-wrap: wrap;
      gap: 1rem;
      padding: 0.75rem 1.5rem;
    }

    h1 {
      font-size: 4rem !important;
    }

    .bg-slate-300 span {
      font-size: 3rem !important;
    }
  }
</style>
