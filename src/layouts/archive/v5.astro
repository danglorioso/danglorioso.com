---
import SpeedInsights from "@vercel/speed-insights/astro";

interface Props {
  title: string;
  description?: string;
}
const { title, description } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content={description} />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="icon" type="image/png" href="/favicon.png" sizes="512x512" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
  </head>
  <body class="bg-blue-950 text-white min-h-screen relative overflow-hidden">
    <!-- Animated Canvas Background -->
    <canvas id="wave-canvas" class="fixed top-0 left-0 w-full h-full -z-10"
    ></canvas>

    <SpeedInsights />

    <script is:inline>
      // Animated Wave Background System
      class WaveBackground {
        constructor() {
          this.canvas = document.getElementById("wave-canvas");
          this.ctx = this.canvas.getContext("2d");
          this.time = 0;
          this.waves = [];
          this.floatingShapes = [];

          this.resize();
          this.createWaves();
          this.createFloatingShapes();
          this.bindEvents();
          this.animate();
        }

        resize() {
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;
        }

        createWaves() {
          // Create multiple wave layers for depth
          this.waves = [
            {
              amplitude: 30,
              frequency: 0.01,
              phase: 0,
              speed: 0.002,
              color: "rgba(59, 130, 246, 0.1)", // blue-500 with low opacity
              yOffset: this.canvas.height * 0.7,
            },
            {
              amplitude: 25,
              frequency: 0.015,
              phase: Math.PI / 3,
              speed: 0.0015,
              color: "rgba(37, 99, 235, 0.08)", // blue-600 with low opacity
              yOffset: this.canvas.height * 0.8,
            },
            {
              amplitude: 20,
              frequency: 0.008,
              phase: Math.PI / 2,
              speed: 0.0025,
              color: "rgba(29, 78, 216, 0.06)", // blue-700 with low opacity
              yOffset: this.canvas.height * 0.9,
            },
          ];
        }

        createFloatingShapes() {
          const shapeCount = Math.min(
            12,
            Math.floor((this.canvas.width * this.canvas.height) / 50000)
          );

          for (let i = 0; i < shapeCount; i++) {
            this.floatingShapes.push({
              x: Math.random() * this.canvas.width,
              y: Math.random() * this.canvas.height,
              size: 20 + Math.random() * 40,
              rotation: Math.random() * Math.PI * 2,
              rotationSpeed: (Math.random() - 0.5) * 0.01,
              vx: (Math.random() - 0.5) * 0.3,
              vy: (Math.random() - 0.5) * 0.3,
              opacity: 0.05 + Math.random() * 0.1,
              type: Math.floor(Math.random() * 3), // 0: circle, 1: triangle, 2: square
              pulsePhase: Math.random() * Math.PI * 2,
              pulseSpeed: 0.001 + Math.random() * 0.002,
            });
          }
        }

        bindEvents() {
          window.addEventListener("resize", () => {
            this.resize();
            this.createWaves();
            this.floatingShapes = [];
            this.createFloatingShapes();
          });
        }

        updateWaves() {
          this.waves.forEach((wave) => {
            wave.phase += wave.speed;
          });
        }

        updateFloatingShapes() {
          this.floatingShapes.forEach((shape) => {
            // Move shape
            shape.x += shape.vx;
            shape.y += shape.vy;
            shape.rotation += shape.rotationSpeed;

            // Gentle pulsing
            shape.currentOpacity =
              shape.opacity +
              Math.sin(this.time * shape.pulseSpeed + shape.pulsePhase) *
                shape.opacity *
                0.5;

            // Wrap around edges
            if (shape.x < -shape.size) shape.x = this.canvas.width + shape.size;
            if (shape.x > this.canvas.width + shape.size) shape.x = -shape.size;
            if (shape.y < -shape.size)
              shape.y = this.canvas.height + shape.size;
            if (shape.y > this.canvas.height + shape.size)
              shape.y = -shape.size;
          });
        }

        drawWaves() {
          this.waves.forEach((wave) => {
            this.ctx.beginPath();
            this.ctx.moveTo(0, wave.yOffset);

            // Create smooth wave using quadratic curves
            for (let x = 0; x <= this.canvas.width; x += 5) {
              const y =
                wave.yOffset +
                Math.sin(x * wave.frequency + wave.phase) * wave.amplitude;
              this.ctx.lineTo(x, y);
            }

            // Complete the wave shape
            this.ctx.lineTo(this.canvas.width, this.canvas.height);
            this.ctx.lineTo(0, this.canvas.height);
            this.ctx.closePath();

            this.ctx.fillStyle = wave.color;
            this.ctx.fill();
          });
        }

        drawFloatingShapes() {
          this.floatingShapes.forEach((shape) => {
            this.ctx.save();
            this.ctx.translate(shape.x, shape.y);
            this.ctx.rotate(shape.rotation);

            this.ctx.fillStyle = `rgba(59, 130, 246, ${shape.currentOpacity})`;
            this.ctx.strokeStyle = `rgba(147, 197, 253, ${shape.currentOpacity * 0.5})`;
            this.ctx.lineWidth = 1;

            switch (shape.type) {
              case 0: // Circle
                this.ctx.beginPath();
                this.ctx.arc(0, 0, shape.size / 2, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.stroke();
                break;

              case 1: // Triangle
                this.ctx.beginPath();
                this.ctx.moveTo(0, -shape.size / 2);
                this.ctx.lineTo(-shape.size / 2, shape.size / 2);
                this.ctx.lineTo(shape.size / 2, shape.size / 2);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();
                break;

              case 2: // Square
                this.ctx.fillRect(
                  -shape.size / 2,
                  -shape.size / 2,
                  shape.size,
                  shape.size
                );
                this.ctx.strokeRect(
                  -shape.size / 2,
                  -shape.size / 2,
                  shape.size,
                  shape.size
                );
                break;
            }

            this.ctx.restore();
          });
        }

        animate() {
          this.time += 16;

          // Clear canvas with blue gradient background
          const gradient = this.ctx.createLinearGradient(
            0,
            0,
            0,
            this.canvas.height
          );
          gradient.addColorStop(0, "#1e3a8a"); // blue-800
          gradient.addColorStop(0.5, "#1e40af"); // blue-700
          gradient.addColorStop(1, "#1d4ed8"); // blue-600

          this.ctx.fillStyle = gradient;
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          // Update and draw all elements
          this.updateWaves();
          this.updateFloatingShapes();

          this.drawWaves();
          this.drawFloatingShapes();

          requestAnimationFrame(() => this.animate());
        }
      }

      // Initialize when DOM is loaded
      if (document.readyState === "loading") {
        document.addEventListener(
          "DOMContentLoaded",
          () => new WaveBackground()
        );
      } else {
        new WaveBackground();
      }
    </script>
  </body>
</html>

<style is:global>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html,
  body {
    font-family: system-ui, sans-serif;
    overflow-x: hidden;
  }

  body {
    background: linear-gradient(180deg, #1e3a8a 0%, #1e40af 50%, #1d4ed8 100%);
    min-height: 100vh;
  }

  /* Custom scrollbar for webkit browsers */
  ::-webkit-scrollbar {
    width: 8px;
  }

  ::-webkit-scrollbar-track {
    background: #1e293b;
  }

  ::-webkit-scrollbar-thumb {
    background: #475569;
    border-radius: 4px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background: #64748b;
  }

  /* Responsive adjustments */
  @media (max-width: 1024px) {
    main {
      flex-direction: column;
      align-items: center;
      text-align: center;
    }

    .flex-1.max-w-lg.ml-16 {
      margin-left: 0;
      margin-top: 3rem;
      max-width: 100%;
    }
  }

  @media (max-width: 768px) {
    nav {
      padding-top: 1.5rem;
      padding-bottom: 2rem;
    }

    nav > div {
      flex-wrap: wrap;
      gap: 1rem;
      padding: 0.75rem 1.5rem;
    }

    h1 {
      font-size: 4rem !important;
    }

    .bg-slate-300 span {
      font-size: 3rem !important;
    }
  }
</style>
