---
import SpeedInsights from "@vercel/speed-insights/astro";

interface Props {
  title: string;
  description?: string;
}
const { title, description } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content={description} />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="icon" type="image/png" href="/favicon.png" sizes="512x512" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
  </head>
  <body class="bg-slate-900 text-white min-h-screen relative overflow-hidden">
    <!-- Animated Neural Network Canvas Background -->
    <canvas id="neural-canvas" class="fixed top-0 left-0 w-full h-full -z-10"
    ></canvas>

    <SpeedInsights />

    <script is:inline>
      // Neural Network Animation System
      class NeuralNetwork {
        constructor() {
          this.canvas = document.getElementById("neural-canvas");
          this.ctx = this.canvas.getContext("2d");
          this.time = 0;
          this.nodes = [];
          this.connections = [];
          this.pulses = [];
          this.mouseX = 0;
          this.mouseY = 0;

          this.resize();
          this.createNetwork();
          this.bindEvents();
          this.animate();
        }

        resize() {
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;
        }

        createNetwork() {
          this.nodes = [];
          this.connections = [];

          // Create a grid-based neural network structure
          const cols = Math.floor(this.canvas.width / 120) + 2;
          const rows = Math.floor(this.canvas.height / 100) + 2;

          // Create nodes in a slightly irregular grid
          for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
              const baseX = (col * this.canvas.width) / (cols - 1);
              const baseY = (row * this.canvas.height) / (rows - 1);

              // Add some randomness to make it look more organic
              const offsetX = (Math.random() - 0.5) * 40;
              const offsetY = (Math.random() - 0.5) * 40;

              this.nodes.push({
                x: baseX + offsetX,
                y: baseY + offsetY,
                originalX: baseX + offsetX,
                originalY: baseY + offsetY,
                size: 2 + Math.random() * 4,
                intensity: 0.3 + Math.random() * 0.4,
                pulsePhase: Math.random() * Math.PI * 2,
                activity: 0,
                maxActivity: 0.8 + Math.random() * 0.2,
                row: row,
                col: col,
              });
            }
          }

          // Create connections between nearby nodes
          this.nodes.forEach((node, i) => {
            this.nodes.forEach((otherNode, j) => {
              if (i !== j) {
                const dx = node.x - otherNode.x;
                const dy = node.y - otherNode.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Connect nodes that are reasonably close
                if (distance < 150 && Math.random() > 0.4) {
                  this.connections.push({
                    start: i,
                    end: j,
                    strength: 0,
                    baseStrength: 0.1 + Math.random() * 0.3,
                    pulseSpeed: 0.01 + Math.random() * 0.02,
                    distance: distance,
                  });
                }
              }
            });
          });
        }

        bindEvents() {
          window.addEventListener("resize", () => {
            this.resize();
            this.createNetwork();
          });

          this.canvas.addEventListener("mousemove", (e) => {
            this.mouseX = e.clientX;
            this.mouseY = e.clientY;

            // Activate nodes near mouse
            this.nodes.forEach((node) => {
              const dx = this.mouseX - node.x;
              const dy = this.mouseY - node.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance < 100) {
                const activation = Math.max(0, 1 - distance / 100);
                node.activity = Math.min(
                  node.maxActivity,
                  node.activity + activation * 0.05
                );
              }
            });
          });
        }

        createPulse(startNode, endNode) {
          this.pulses.push({
            startNode: startNode,
            endNode: endNode,
            progress: 0,
            speed: 0.02 + Math.random() * 0.03,
            intensity: 0.6 + Math.random() * 0.4,
            life: 1.0,
          });
        }

        updateNetwork() {
          // Update node activities
          this.nodes.forEach((node) => {
            // Natural decay
            node.activity *= 0.995;

            // Random activation
            if (Math.random() < 0.001) {
              node.activity = Math.min(
                node.maxActivity,
                node.activity + Math.random() * 0.3
              );
            }

            // Gentle floating motion
            node.x =
              node.originalX +
              Math.sin(this.time * 0.0008 + node.pulsePhase) * 3;
            node.y =
              node.originalY +
              Math.cos(this.time * 0.0006 + node.pulsePhase) * 2;
          });

          // Update connections and create pulses
          this.connections.forEach((connection) => {
            const startNode = this.nodes[connection.start];
            const endNode = this.nodes[connection.end];

            // Connection strength based on node activities
            const avgActivity = (startNode.activity + endNode.activity) / 2;
            connection.strength = connection.baseStrength * (0.2 + avgActivity);

            // Occasionally create pulses along active connections
            if (startNode.activity > 0.3 && Math.random() < 0.005) {
              this.createPulse(connection.start, connection.end);
            }
          });

          // Update pulses
          this.pulses = this.pulses.filter((pulse) => {
            pulse.progress += pulse.speed;
            pulse.life *= 0.98;

            // Activate end node when pulse arrives
            if (pulse.progress >= 1) {
              const endNode = this.nodes[pulse.endNode];
              endNode.activity = Math.min(
                endNode.maxActivity,
                endNode.activity + pulse.intensity * 0.2
              );
              return false;
            }

            return pulse.life > 0.1;
          });
        }

        drawNetwork() {
          // Draw connections
          this.connections.forEach((connection) => {
            if (connection.strength > 0.05) {
              const startNode = this.nodes[connection.start];
              const endNode = this.nodes[connection.end];

              this.ctx.strokeStyle = `rgba(100, 200, 255, ${connection.strength})`;
              this.ctx.lineWidth = 0.5 + connection.strength * 2;
              this.ctx.beginPath();
              this.ctx.moveTo(startNode.x, startNode.y);
              this.ctx.lineTo(endNode.x, endNode.y);
              this.ctx.stroke();
            }
          });

          // Draw pulses
          this.pulses.forEach((pulse) => {
            const startNode = this.nodes[pulse.startNode];
            const endNode = this.nodes[pulse.endNode];

            const x = startNode.x + (endNode.x - startNode.x) * pulse.progress;
            const y = startNode.y + (endNode.y - startNode.y) * pulse.progress;

            const opacity = pulse.intensity * pulse.life;

            // Pulse glow
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI * 2);
            this.ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            this.ctx.fill();

            // Pulse trail
            this.ctx.beginPath();
            this.ctx.arc(x, y, 8, 0, Math.PI * 2);
            this.ctx.fillStyle = `rgba(100, 200, 255, ${opacity * 0.3})`;
            this.ctx.fill();
          });

          // Draw nodes
          this.nodes.forEach((node) => {
            const brightness = node.intensity + node.activity;
            const pulseEffect =
              1 + Math.sin(this.time * 0.003 + node.pulsePhase) * 0.2;

            // Node glow
            this.ctx.beginPath();
            this.ctx.arc(
              node.x,
              node.y,
              node.size * 2 * pulseEffect,
              0,
              Math.PI * 2
            );
            this.ctx.fillStyle = `rgba(100, 200, 255, ${brightness * 0.2})`;
            this.ctx.fill();

            // Node core
            this.ctx.beginPath();
            this.ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2);
            this.ctx.fillStyle = `rgba(200, 230, 255, ${brightness})`;
            this.ctx.fill();

            // Bright center for active nodes
            if (node.activity > 0.2) {
              this.ctx.beginPath();
              this.ctx.arc(node.x, node.y, node.size * 0.5, 0, Math.PI * 2);
              this.ctx.fillStyle = `rgba(255, 255, 255, ${node.activity})`;
              this.ctx.fill();
            }
          });
        }

        animate() {
          this.time += 16;

          // Clear canvas with dark gradient background
          const gradient = this.ctx.createRadialGradient(
            this.canvas.width / 2,
            this.canvas.height / 2,
            0,
            this.canvas.width / 2,
            this.canvas.height / 2,
            Math.max(this.canvas.width, this.canvas.height)
          );
          gradient.addColorStop(0, "#1e293b"); // slate-800
          gradient.addColorStop(0.7, "#0f172a"); // slate-900
          gradient.addColorStop(1, "#020617"); // slate-950

          this.ctx.fillStyle = gradient;
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          // Update and draw the neural network
          this.updateNetwork();
          this.drawNetwork();

          requestAnimationFrame(() => this.animate());
        }
      }

      // Initialize when DOM is loaded
      if (document.readyState === "loading") {
        document.addEventListener(
          "DOMContentLoaded",
          () => new NeuralNetwork()
        );
      } else {
        new NeuralNetwork();
      }
    </script>
  </body>
</html>

<style is:global>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html,
  body {
    font-family: system-ui, sans-serif;
    overflow-x: hidden;
  }

  body {
    background: radial-gradient(
      circle at center,
      #1e293b 0%,
      #0f172a 70%,
      #020617 100%
    );
    min-height: 100vh;
  }

  /* Custom scrollbar for webkit browsers */
  ::-webkit-scrollbar {
    width: 8px;
  }

  ::-webkit-scrollbar-track {
    background: #1e293b;
  }

  ::-webkit-scrollbar-thumb {
    background: #475569;
    border-radius: 4px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background: #64748b;
  }

  /* Responsive adjustments */
  @media (max-width: 1024px) {
    main {
      flex-direction: column;
      align-items: center;
      text-align: center;
    }

    .flex-1.max-w-lg.ml-16 {
      margin-left: 0;
      margin-top: 3rem;
      max-width: 100%;
    }
  }

  @media (max-width: 768px) {
    nav {
      padding-top: 1.5rem;
      padding-bottom: 2rem;
    }

    nav > div {
      flex-wrap: wrap;
      gap: 1rem;
      padding: 0.75rem 1.5rem;
    }

    h1 {
      font-size: 4rem !important;
    }

    .bg-slate-300 span {
      font-size: 3rem !important;
    }
  }
</style>
